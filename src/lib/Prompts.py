from lib.InferenceType import InferenceType
from lib.KnowledgeLevel import KnowledgeLevel
from lib.Utils import Utils


# This class is for prompts used for building personalized explanations in the
# chat environment of the user interface.
class ChatPrompt:

    def __init__(
        self,
        inference_type: InferenceType,
        user_knowledge_level: KnowledgeLevel,
        wants_feature_ablation: bool,
        wants_counterfactual: bool,
    ):

        utils = Utils()

        if utils.is_invalid_inference_type(inference_type):
            raise ValueError(f"Invalid inference type: {inference_type}")

        if utils.is_invalid_knowledge_level(user_knowledge_level):
            raise ValueError(f"Invalid user knowledge level: {user_knowledge_level}")

        self.inference_type = inference_type
        self.user_knowledge_level = user_knowledge_level
        self.wants_feature_ablation = wants_feature_ablation
        self.wants_counterfactual = wants_counterfactual

    def __get_header(self):

        prompt = "You are a machine learning expert chatbot assisting a user named {username} in understanding predictions done by a generative model."

        if self.wants_feature_ablation or self.wants_counterfactual:
            prompt += " You are part of a user interface and your task is to clarify the explanations generated by the XAI methods."

        match self.inference_type:

            case InferenceType.SentimentAnalysis:

                prompt += " The underlying model used for the predictions is '{model-name}' which performs sentiment analysis (determining if text is positive or negative)."

            case InferenceType.TextGeneration:

                prompt += " The underlying model used for the predictions is '{model-name}' which performs text generation based on input text."

        return prompt

    def __get_user_background(self):

        user_background_templates = {
            KnowledgeLevel.Beginner: "The user is a beginner when it comes to XAI and explanations for GenAI model predictions.",
            KnowledgeLevel.Advanced: "The user is familiar with XAI and GenAI model prediction explanations, but not an expert.",
            KnowledgeLevel.Expert: "The user is an expert when it comes to XAI and GenAI model prediction explanations.",
        }

        return (
            user_background_templates[self.user_knowledge_level]
            + " Consider this information in your explanations."
        )

    def __get_xai(self):

        methods_used = (
            "Feature Ablation (a perturbation-based XAI technique)"
            if self.wants_feature_ablation
            else (
                ""
                + (
                    " and "
                    if self.wants_feature_ablation and self.wants_counterfactual
                    else ""
                )
                + "Counterfactual (a sample-based XAI technique)"
                if self.wants_counterfactual
                else ""
            )
        )

        if self.inference_type == InferenceType.SentimentAnalysis:

            base_prompt = (
                "The following text was classified as '{sentiment}': '{text}'."
            )

            if self.wants_feature_ablation or self.wants_counterfactual:
                base_prompt += f"The XAI method(s) used for explaining the predictions was/were '{methods_used}' and produced the following results:"

            feature_ablations_templates = {
                KnowledgeLevel.Beginner: """
                    1. Feature Ablation
                    The attribution scores calculated are '{fa-attributions}'. Because the user is a beginner when it comes to XAI, not all attributions were used in the html visualization: {fa-html}. Focus on the key words highlighted in the html. The html is also displayed on the user interface. Do not talk about individual attribution scores.
                      """,
                KnowledgeLevel.Advanced: """
                    1. Feature Ablation
                    The attribution scores calculated are '{fa-attributions}'. To visualize the attribution scores to the user, we used gradient colors: {fa-html}. The html is displayed on the user interface. Do not talk about individual attribution scores, but consider all attributions in your explanations.
                      """,
                KnowledgeLevel.Expert: """
                    1. Feature Ablation
                    The attribution scores calculated are '{fa-attributions}'. To visualize the attribution scores to the user, we used gradient colors: {fa-html}. The html is displayed on the user interface. Additionally, we created a bar chart for further visualization of individals word scores, which the user will share with you in the next message.
                    """,
            }

            counterfactuals_templates = {
                KnowledgeLevel.Beginner: """
                    2. Counterfactual
                    The counterfactual text created is '{cf-text}' and has the sentiment '{cf-sentiment}'. The text was also visualized in the user interface using the following html, which highlights the words which were changed to the original text: {cf-text-html}
                    """,
                KnowledgeLevel.Advanced: """
                    2. Counterfactual
                    The counterfactual text created is '{cf-text}' and has the sentiment '{cf-sentiment}'. The text was also visualized in the user interface using the following html, which highlights the words which were changed to the original text: {cf-text-html}. Additionally, the key words, which were most influencial when calculating the counterfactual are displayed: {cf-key-words-html}
                    """,
                KnowledgeLevel.Expert: """
                    2. Counterfactual
                    The counterfactual text created is '{cf-text}' and has the sentiment '{cf-sentiment}'. The text was also visualized in the user interface using the following html, which highlights the words which were changed to the original text: {cf-text-html}. Additionally, the key words, which were most influencial when calculating the counterfactual are displayed: {cf-key-words-html} & the latent features, which were also influential for the sentiment prediction: {cf-latent-features-html}.
                    """,
            }

        if self.inference_type == InferenceType.TextGeneration:

            base_prompt = "The model was given the input: '{model-input}', and generated the following output: '{model-output}'."

            if self.wants_feature_ablation or self.wants_counterfactual:
                base_prompt += f"The XAI method(s) used for explaining the generated text was/were '{methods_used}' and produced the following results:"

            feature_ablations_templates = {
                KnowledgeLevel.Beginner: """
                    1. Feature Ablation
                    For the input tokens '{fa-input-tokens}' and the output tokens '{fa-output-tokens}', the calculated attribution scores are '{fa-attributions}'. Because the user is a beginner when it comes to XAI, only the most important input token for each word is displayed in a table: 
                    {fa-most-important-tokens-df}
                    Focus on the key token listed in the dataframe. The dataframe is also displayed on the user interface as a table. Do not talk about individual attribution scores.
                    """,
                KnowledgeLevel.Advanced: """
                    1. Feature Ablation
                    For the input tokens '{fa-input-tokens}' and the output tokens '{fa-output-tokens}', the calculated attribution scores are '{fa-attributions}'. To visualize the attributions scores to the user, we used gradient colors in a heatmap. The heatmap will use darker red colors to indicate negative attributions and darker green colors for positive attributions. The user will share the heatmap with you in the next message. Do not talk about individual attribution scores, but use them as background knowledge for you to answer questions about token importance.
                    """,
                KnowledgeLevel.Expert: """
                    1. Feature Ablation
                    For the input tokens '{fa-input-tokens}' and the output tokens '{fa-output-tokens}', the calculated attribution scores are '{fa-attributions}'. To visualize the attributions scores to the user, we used gradient colors in a heatmap. The heatmap will use darker red colors to indicate negative attributions and darker green colors for positive attributions. The user will share the heatmap with you in the next message.
                    """,
            }

            counterfactuals_templates = {
                KnowledgeLevel.Beginner: """
                    2. Counterfactual
                    The counterfactual XAI method generated the following alternative input sequences: "{cf-alternative-versions}". The model was run again on each alternative input. The counterfactuals were also visualized in the user interface using the following html, which highlights the words which were changed to the original text: {cf-text-html-list}
                    """,
                KnowledgeLevel.Advanced: """
                    2. Counterfactual
                    The counterfactual XAI method generated the following alternative input sequences: "{cf-alternative-versions}". The model was run again on each alternative input. The key sentence parts identified for the counterfactuals are '{cf-key-components}'. The counterfactuals were also visualized in the user interface using the following html, which highlights the words which were changed to the original text: {cf-text-html-list}
                    """,
                KnowledgeLevel.Expert: """
                    2. Counterfactual
                    The counterfactual XAI method generated the following alternative input sequences: "{cf-alternative-versions}". The model was run again on each alternative input. The key sentence parts identified for the counterfactuals are '{cf-key-components}'. The counterfactuals were also visualized in the user interface using the following html, which highlights the words which were changed to the original text: {cf-text-html-list}
                    """,
            }

        explanations = []

        explanations.append(base_prompt)

        if self.wants_feature_ablation:
            explanations.append(feature_ablations_templates[self.user_knowledge_level])

        if self.wants_counterfactual:
            explanations.append(counterfactuals_templates[self.user_knowledge_level])

        return "\n".join(explanations)

    def __get_task(self):

        prompt = ""

        if self.wants_feature_ablation or self.wants_counterfactual:
            prompt += "Write an initial explanation about how the prediction was based based on the XAI method(s) provided."
        else:
            prompt += "Write an intitial explanation about how the prediction was probably made. Do not talk about XAI methods, rather talk about possible rational explanations."

        prompt += " It should be around 200 words long. Start your explanation with 'Hi {username}!'. Expect the user to ask follow up questions."

        return prompt

    def build(self):

        prompt_parts = [
            self.__get_header(),
            self.__get_user_background(),
            self.__get_xai(),
            self.__get_task(),
        ]

        prompt = "\n".join(prompt_parts)

        # print(prompt)

        return prompt


# This class is for prompts used for generating explanations for XAI methods
# Currently used for Counterfactuals & Follow Up Questions
class XAIPrompt:

    def __init__(self, inference_type, goal):

        utils = Utils()

        if utils.is_invalid_inference_type(inference_type):
            raise ValueError(f"Invalid inference type: {inference_type}")

        self.inference_type = inference_type
        self.goal = goal

    def get_step(self, step=1):

        if self.goal == "counterfactual":

            if self.inference_type == InferenceType.SentimentAnalysis:

                match step:

                    case 1:

                        return """
                        You are an oracle explanation module in a machine learning pipeline. In the task of sentiment-analysis, a trained black-box classifier correctly predicted the sentiment "{sentiment}" for the following text. Think about why the model predicted the "{sentiment}" sentiment and identify the latent features that caused the label. List ONLY the latent features as a comma separated list, without any explanation.
                        Examples of latent features are "tone", "ambiguity in text", etc.

                        Text: {text}

                        Begin!
                        """

                    case 2:

                        return """
                        Identify the words in the text that are associated with the latent features: {latent-features} and output the identified words as a comma separated list.
                        """

                    case 3:

                        return """
                        "{identified-words}"
                        Generate a minimally edited version of the original text by ONLY changing a minimal set of the words you identified, in order to change the label. It is okay if the semantic meaning of the original text is altered. Make sure the generated text makes sense and is plausible.
                        """

            elif self.inference_type == InferenceType.TextGeneration:

                match step:

                    case 1:

                        return """
                        You are an oracle explanation module in a machine learning pipeline.
                        In the task of text generation, a generative model got the input "{input-text}" and generated the output "{output-text}".
                        Identify key components of the input text that could influence the generated output. These components can be words, phrases, or stylistic elements.
                        List ONLY the key components as a comma separated list, without any explanation.
                        """

                    case 2:

                        return """
                        Modify the key components to create three alternative versions of the input text.
                        List ONLY the three alternative versions of the input text as a semicolon separated list, without any explanation.
                        """

        if self.goal == "follow_up_questions":

            return """
            Come up with three potential follow up question for the user, to make it easier for him to interact with the explanation(s). Consider the previous message history when creating the questions to avoid dublicate or redundant questions.
            The questions will be displayed in buttons below the chat, so make them short. The questions should be phrased from the user perspective.
            Output the follow up questions in a json list with the key "follow_up_questions".
            """
